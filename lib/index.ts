/** Payload is known as the "body" of a Request. The payload must be JSON serializable. */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Payload = any;

/**
 * Client is a convenience class for interacting with the Rent Dynamics services.
 *
 * Note if this class does not suit your needs, it may be wise to roll your own implementation using
 * the {@linkcode ClientHelpers} class.
 */
export class Client {
  /**
   * authToken if defined, authToken is used to make authenticated requests. Note authToken is not
   * typically get/set manually, but instead is managed through the login/logout methods.
   */
  public authToken: string | undefined;
  private readonly helpers: ClientHelpers;

  constructor(options: ClientOptions) {
    this.helpers = new ClientHelpers(options);
  }

  /**
   * get wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @example get('/foo');
   */
  public async get(endpoint: string) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, undefined, this.authToken);
    return fetch(fullUrl.replace(/\|/g, '%7C'), {
      method: 'GET',
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * put wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @param payload a JSON serializable object.
   * @example put('/foo', { bar: 1 });
   */
  public async put(endpoint: string, payload: Payload) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, payload, this.authToken);
    return fetch(fullUrl, {
      method: 'PUT',
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
  }

  /**
   * post wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @param payload a JSON serializable object.
   * @example post('/foo', { bar: 1 });
   */
  public async post(endpoint: string, payload: Payload) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, payload, this.authToken);
    return fetch(fullUrl, {
      method: 'POST',
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
  }

  /**
   * delete wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @example delete('/foo/1');
   */
  public async delete(endpoint: string) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, undefined, this.authToken);
    return fetch(fullUrl, {
      method: 'DELETE',
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * login enables an instance of {@linkcode Client} to make authenticated requests to the Rent
   * Dynamics API.
   */
  public async login(username: string, password: string) {
    const _password = await this.helpers.encryptPassword(password);
    const endpoint = '/auth/login';
    const result = await this.post(endpoint, { username, password: _password });
    if (!result.ok) {
      return result;
    }
    const { token } = await result.json();
    this.authToken = token;
    return result;
  }

  /** logout invalidates the users session generated by {@linkcode login}. */
  public async logout() {
    const endpoint = '/auth/logout';
    const result = await this.post(endpoint, { authToken: this.authToken });
    if (!result.ok) {
      return result;
    }
    this.authToken = undefined;
    return result;
  }
}

/** BASE_URL is a collection of base urls for each dev/prod Rent Dynamics service. */
export enum BASE_URL {
  DEV_RD = 'https://api.rentdynamics.dev',
  PROD_RD = 'https://api.rentdynamics.com',
  DEV_RP = 'https://api-dev.rentplus.com',
  PROD_RP = 'https://api.rentplus.com'
}

export type RdEncoder = Pick<TextEncoder, 'encode'>;

export type RdCryptographer = Pick<SubtleCrypto, 'importKey'> &
  Pick<SubtleCrypto, 'sign'> &
  Pick<SubtleCrypto, 'digest'>;

/** ClientOptions is consumed and updated by {@linkcode ClientHelpers}. */
export class ClientOptions {
  /** apiKey if defined apiKey is used to calculate auth headers. */
  public apiKey: string | undefined;
  /** apiSecretKey if defined apiSecretKey is used to calculate auth headers.  */
  public apiSecretKey: string | undefined;
  /**
   * baseUrl is the base request url. The default is the development rentdynamics api. A custom
   * string may be provided beyond the {@linkcode BASE_URL} options.
   */
  public baseUrl: BASE_URL | string = BASE_URL.DEV_RD;

  /**
   * getEncoder is used to encode text. The encoder can be overridden as needed. For example in a
   * node environment.
   * @example
   * const options = new ClientOptions();
   * options.getEncoder = async () => new (await import('util')).TextEncoder();
   */
  public getEncoder = async (): Promise<RdEncoder> => new TextEncoder();

  /**
   * getCryptographer is used for cryptography. The cryptographer can be overridden as needed. For
   * example in a node environment.
   * @example
   * const options = new ClientOptions();
   * options.getCryptographer = async () => (await import('crypto')).subtle;
   */
  public getCryptographer = async (): Promise<RdCryptographer> => crypto.subtle;
}

/**
 * ClientHelpers is a collection of utilities consumed by {@linkcode Client}. ClientHelpers can be
 * used to calculate headers in case a consumer wants to build their own API client.
 */
export class ClientHelpers {
  private options: ClientOptions;

  constructor(options: ClientOptions) {
    this.options = options;
  }

  /**
   * baseUrl is the base url used throughout the {@linkcode ClientHelpers} instance. It is initially
   * configured through {@linkcode ClientOptions}.
   */
  get baseUrl() {
    return this.options.baseUrl;
  }

  /**
   * getTimestamp is used to calculate the timestamp header. This method is not likely to be called
   * on it's own. Instead, it is typically used to mock the current time.
   */
  public getTimestamp() {
    return Date.now();
  }

  /**
   * getHeaders creates headers for the given params. If an auth token is included, this method will
   * generate an `Authorization` header.
   */
  public async getHeaders(
    endpoint: string,
    payload?: Payload | undefined,
    authToken?: string | undefined
  ) {
    const headers: Record<string, string> = {};
    if (this.options.apiKey && this.options.apiSecretKey) {
      if (typeof payload !== 'undefined') {
        payload = this.formatPayload(payload);
        payload = JSON.stringify(payload);
        if (['{}', '[]'].includes(payload)) {
          payload = '';
        }
      }
      const timestamp = this.getTimestamp();
      const nonce = await this.getNonce(timestamp, endpoint, payload);
      if (authToken) {
        headers.Authorization = 'TOKEN ' + authToken;
      }
      headers['x-rd-api-key'] = this.options.apiKey;
      headers['x-rd-api-nonce'] = nonce;
      headers['x-rd-timestamp'] = timestamp.toString();
      return headers;
    }
    return headers;
  }

  /** formatPayload formats the payload for nonce calculation. */
  public formatPayload(payload: Payload): Payload {
    let formattedPayload: Payload = {};
    if (payload === undefined || payload === null) {
      formattedPayload = null;
    } else if (payload !== Object(payload)) {
      formattedPayload = payload;
    } else if (Array.isArray(payload)) {
      formattedPayload = [];
      payload.forEach((_, index) => {
        formattedPayload[index] = this.formatPayload(payload[index]);
      });
    } else {
      Object.keys(payload)
        .sort()
        .forEach(k => {
          if (typeof payload[k] === 'object') {
            formattedPayload[k] = this.formatPayload(payload[k]);
          } else if (typeof payload[k] === 'string') {
            formattedPayload[k] = payload[k].replace(/ /g, '');
          } else {
            formattedPayload[k] = payload[k];
          }
        });
    }
    return formattedPayload;
  }

  /** getNonce calculates the nonce for the given params. */
  public async getNonce(timestamp: number, url: string, payloadStr?: string): Promise<string> {
    if (!this.options.apiSecretKey) return Promise.resolve('');
    const encodedUrl = encodeURI(url)
      .replace(/%7[Cc]/g, '|')
      .replace(/%20/g, ' ');
    const nonceStr =
      typeof payloadStr !== 'undefined'
        ? timestamp + encodedUrl + payloadStr
        : timestamp + encodedUrl;
    const cryptographer = await this.options.getCryptographer();
    const encoder = await this.options.getEncoder();
    const key = encoder.encode(this.options.apiSecretKey);
    const data = encoder.encode(nonceStr);
    const algorithm = { name: 'HMAC', hash: 'SHA-1' };
    const hmac = await cryptographer.importKey('raw', key, algorithm, false, ['sign']);
    const signed = await cryptographer.sign(algorithm.name, hmac, data);
    return _hexDigest(signed);
  }

  /** encryptPassword encrypts the password for login. */
  public async encryptPassword(password: string) {
    const cryptographer = await this.options.getCryptographer();
    const encoder = await this.options.getEncoder();
    const encodedPassword = encoder.encode(password);
    const digestedPassword = await cryptographer.digest('SHA-1', encodedPassword);
    return _hexDigest(digestedPassword);
  }
}

const _hexDigest = (buf: ArrayBuffer): string =>
  Array.from(new Uint8Array(buf))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
