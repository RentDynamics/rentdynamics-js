/** Payload is known as the "body" of a Request. The payload must be JSON serializable. */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Payload = any;

/**
 * Client is a convenience class for interacting with the Rent Dynamics services.
 *
 * Note if this class does not suit your needs, it may be wise to roll your own implementation using
 * the ClientHelpers class.
 */
export class Client {
  public readonly helpers: ClientHelpers;

  constructor(options: ClientOptions) {
    this.helpers = new ClientHelpers(options);
  }

  /**
   * get wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @example get('/foo');
   */
  public async get(endpoint: string) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint);
    return fetch(fullUrl.replace(/\|/g, '%7C'), {
      method: 'GET',
      headers
    });
  }

  /**
   * put wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @param payload a JSON serializable object.
   * @example put('/foo', { bar: 1 });
   */
  public async put(endpoint: string, payload: Payload) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, payload);
    return fetch(fullUrl, {
      method: 'PUT',
      headers,
      body: JSON.stringify(payload)
    });
  }

  /**
   * post wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @param payload a JSON serializable object.
   * @example post('/foo', { bar: 1 });
   */
  public async post(endpoint: string, payload: Payload) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint, payload);
    return fetch(fullUrl, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload)
    });
  }

  /**
   * delete wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl.
   * @example delete('/foo/1');
   */
  public async delete(endpoint: string) {
    const fullUrl = this.helpers.baseUrl + endpoint;
    const headers = await this.helpers.getHeaders(endpoint);
    return fetch(fullUrl, {
      method: 'DELETE',
      headers
    });
  }

  /**
   * login enables an instance of Client to make authenticated requests to the Rent Dynamics API.
   */
  public async login(username: string, password: string) {
    const _password = await this.helpers.encryptPassword(password);
    const endpoint = '/auth/login';
    const result = await this.post(endpoint, { username, password: _password });
    if (!result.ok) {
      return result;
    }
    this.helpers.authToken = await result.text();
    return result;
  }

  /** logout invalidates the users session generated by login. */
  public async logout() {
    const endpoint = '/auth/logout';
    const result = await this.post(endpoint, { authToken: this.helpers.authToken });
    if (!result.ok) {
      return result;
    }
    this.helpers.authToken = undefined;
    return result;
  }
}

/** BASE_URL is a collection of base urls for each dev/prod Rent Dynamics service. */
export const enum BASE_URL {
  DEV_RD = 'https://api.rentdynamics.dev',
  PROD_RD = 'https://api.rentdynamics.com',
  DEV_RP = 'https://api-dev.rentplus.com',
  PROD_RP = 'https://api.rentplus.com'
}

/** ClientOptions is consumed and updated by ClientHelpers. */
export class ClientOptions {
  /** apiKey if defined apiKey is used to calculate auth headers. */
  public apiKey: string | undefined;
  /** apiSecretKey if defined apiSecretKey is used to calculate auth headers.  */
  public apiSecretKey: string | undefined;
  /** authToken if defined authToken is used to calculate auth headers. */
  public authToken: string | undefined;
  /**
   * baseUrl is the base request url. The default is the development rentdynamics api. A custom
   * string may be provided beyond the BASE_URL options.
   */
  public baseUrl: BASE_URL | string = BASE_URL.DEV_RD;
}

/**
 * ClientHelpers is a collection of utilities consumed by Client. ClientHelpers can be used to
 * calculate headers in case a consumer wants to build their own API client.
 */
export class ClientHelpers {
  private options: ClientOptions;

  constructor(options: ClientOptions) {
    this.options = options;
  }

  /**
   * baseUrl is the base url used throughout the ClientHelpers instance. It is initially configured
   * through ClientOptions.
   */
  get baseUrl() {
    return this.options.baseUrl;
  }

  /**
   * authToken is sent by getHeaders. if authToken is not defined it will be excluded from headers.
   */
  get authToken() {
    return this.options.authToken;
  }
  set authToken(t: string | undefined) {
    this.options.authToken = t;
  }

  /** formatPayload formats the payload for nonce calculation. */
  public formatPayload(payload: Payload): Payload {
    let formattedPayload: Payload = {};
    if (payload === undefined || payload === null) {
      formattedPayload = null;
    } else if (payload !== Object(payload)) {
      formattedPayload = payload;
    } else if (Array.isArray(payload)) {
      formattedPayload = [];
      payload.forEach((_, index) => {
        formattedPayload[index] = this.formatPayload(payload[index]);
      });
    } else {
      Object.keys(payload)
        .sort()
        .forEach(k => {
          if (typeof payload[k] === 'object') {
            formattedPayload[k] = this.formatPayload(payload[k]);
          } else if (typeof payload[k] === 'string') {
            formattedPayload[k] = payload[k].replace(/ /g, '');
          } else {
            formattedPayload[k] = payload[k];
          }
        });
    }
    return formattedPayload;
  }

  /** getHeaders creates headers for the given params. */
  public async getHeaders(endpoint: string, payload?: Payload) {
    const headers: Record<string, string> = {};
    if (this.options.apiKey && this.options.apiSecretKey) {
      if (typeof payload !== 'undefined') {
        payload = this.formatPayload(payload);
      }
      const timestamp = Date.now();
      const nonce = await this.getNonce(timestamp, endpoint, JSON.stringify(payload));
      if (this.options.authToken) {
        headers.Authorization = 'TOKEN ' + this.options.authToken;
      }
      headers['x-rd-api-key'] = this.options.apiKey;
      headers['x-rd-api-nonce'] = nonce;
      headers['x-rd-timestamp'] = timestamp.toString();
      headers['Content-Type'] = 'application/json';
      return headers;
    }
    return headers;
  }

  /** getNonce calculates the nonce for the given params. */
  public async getNonce(timestamp: number, url: string, payloadStr?: string): Promise<string> {
    if (!this.options.apiSecretKey) return Promise.resolve('');
    const encodedUrl = encodeURI(url).replace(/%7[Cc]/g, '|');
    const nonceStr =
      typeof payloadStr !== 'undefined'
        ? timestamp + encodedUrl + payloadStr
        : timestamp + encodedUrl;
    const encoder = new TextEncoder();
    const key = encoder.encode(this.options.apiSecretKey);
    const data = encoder.encode(nonceStr);
    const algorithm = { name: 'HMAC', hash: 'SHA-1' };
    const hmac = await crypto.subtle.importKey('raw', key, algorithm, false, ['sign']);
    const signed = await crypto.subtle.sign(algorithm.name, hmac, data);
    return _hexDigest(signed);
  }

  /** encryptPassword encrypts the password for login. */
  public async encryptPassword(password: string) {
    const encodedPassword = new TextEncoder().encode(password);
    const digestedPassword = await crypto.subtle.digest('SHA-1', encodedPassword);
    return _hexDigest(digestedPassword);
  }
}

const _hexDigest = (buf: ArrayBuffer): string =>
  Array.from(new Uint8Array(buf))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
