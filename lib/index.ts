type Payload = Record<string, any> | Record<string, any>[];

/**
 * Client is a convenience class for interacting with the Rent Dynamics services.
 *
 * Note if this class does not suit your needs, it may be wise to roll your own implementation using
 * the ClientHelpers class.
 */
export class Client {
  private helpers: ClientHelpers;
  private options: ClientOptions;

  constructor(options: ClientOptions) {
    this.options = options;
    this.helpers = new ClientHelpers(options);
  }

  /**
   * get wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl
   * @example get('/foo');
   */
  public get(endpoint: string) {
    const options: RequestInit = {
      method: 'GET',
      headers: this.helpers.getHeaders(endpoint)
    };
    const fullUrl = this.options.baseUrl + endpoint;
    return fetch(fullUrl.replace(/\|/g, '%7C'), options);
  }

  /**
   * put wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl
   * @param payload a JSON serializable object
   * @example put('/foo', { bar: 1 });
   */
  public put(endpoint: string, payload: Payload) {
    const options: RequestInit = {
      method: 'PUT',
      headers: this.helpers.getHeaders(endpoint, payload),
      body: JSON.stringify(payload)
    };
    const fullUrl = this.options.baseUrl + endpoint;
    return fetch(fullUrl, options);
  }

  /**
   * post wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl
   * @param payload a JSON serializable object
   * @example post('/foo', { bar: 1 });
   */
  public post(endpoint: string, payload: Payload) {
    const options: RequestInit = {
      method: 'POST',
      headers: this.helpers.getHeaders(endpoint, payload),
      body: JSON.stringify(payload)
    };
    const fullUrl = this.options.baseUrl + endpoint;
    return fetch(fullUrl, options);
  }

  /**
   * delete wraps a request library to work with the Rent Dynamics API.
   * @param endpoint the path following the baseUrl
   * @example delete('/foo/1');
   */
  public delete(endpoint: string) {
    const options: RequestInit = {
      method: 'DELETE',
      headers: this.helpers.getHeaders(endpoint)
    };
    const fullUrl = this.options.baseUrl + endpoint;
    return fetch(fullUrl, options);
  }

  /** login enables an instance of Client to make authenticated requests to the Rent Dynamics API */
  public async login(username: string, password: string) {
    const _password = await this.helpers.encryptPassword(password);
    const endpoint = '/auth/login';
    const result = await this.post(endpoint, { username, password: _password });
    if (!result.ok) {
      return result;
    }
    this.options.authToken = await result.text();
    return result;
  }

  /** logout invalidates the users session generated by login */
  public async logout() {
    const endpoint = '/auth/logout';
    const res = await this.post(endpoint, { authToken: this.options.authToken });
    this.options.authToken = undefined;
    return res;
  }
}

/** BASE_URL is a collection of base urls for each dev/prod Rent Dynamics service. */
export const enum BASE_URL {
  DEV_RD = 'https://api.rentdynamics.dev',
  PROD_RD = 'https://api.rentdynamics.com',
  DEV_RP = 'https://api-dev.rentplus.com',
  PROD_RP = 'https://api.rentplus.com'
}

export class ClientOptions {
  public apiKey: string | undefined;
  public apiSecretKey: string | undefined;
  public authToken: string | undefined;
  public baseUrl: string;

  /**
   * @param baseUrl is the base request url. The default is the development rentdynamics api. The
   * BASE_URL enum can be used or a custom value can be supplied.
   */
  constructor(baseUrl: BASE_URL | string = BASE_URL.DEV_RD) {
    this.baseUrl = baseUrl;
  }
}

/**
 * ClientHelpers is a collection of utilities consumed by Client. ClientHelpers can be used to
 * calculate headers in case a consumer wants to build their own API client.
 */
export class ClientHelpers {
  private options: ClientOptions;

  constructor(options: ClientOptions) {
    this.options = options;
  }

  public formatPayload(payload: any): any {
    let formattedPayload: any = {};

    if (typeof payload === undefined || payload === null) {
      formattedPayload = null;
    } else if (payload !== Object(payload)) {
      formattedPayload = payload;
    } else if (Array.isArray(payload)) {
      formattedPayload = [];

      for (let i = 0; i < payload.length; i++) {
        formattedPayload[i] = this.formatPayload(payload[i]);
      }
    } else {
      Object.keys(payload)
        .sort()
        .forEach((k: any, v: any) => {
          if (typeof payload[k] == 'object') {
            formattedPayload[k] = this.formatPayload(payload[k]);
          } else if (typeof payload[k] == 'string') {
            formattedPayload[k] = payload[k].replace(/ /g, '');
          } else {
            formattedPayload[k] = payload[k];
          }
        }, this);
    }
    return formattedPayload;
  }

  public getHeaders(endpoint: string, payload?: Payload) {
    const headers: any = {};
    if (this.options.apiKey && this.options.apiSecretKey) {
      if (typeof payload !== 'undefined') {
        payload = this.formatPayload(payload);
      }
      const timestamp = Date.now();
      const nonce = this.getNonce(timestamp, endpoint, JSON.stringify(payload));
      if (this.options.authToken) {
        headers['Authorization'] = 'TOKEN ' + this.options.authToken;
      }
      headers['x-rd-api-key'] = this.options.apiKey;
      headers['x-rd-api-nonce'] = nonce;
      headers['x-rd-timestamp'] = timestamp.toString();
      headers['Content-Type'] = 'application/json';
      return headers;
    }
    return headers;
  }

  public async getNonce(timestamp: number, url: string, payloadStr?: string): Promise<string> {
    if (!this.options.apiSecretKey) return Promise.resolve('');
    const encodedUrl = encodeURI(url).replace(/%7[Cc]/g, '|');
    const nonceStr =
      typeof payloadStr !== 'undefined'
        ? timestamp + encodedUrl + payloadStr
        : timestamp + encodedUrl;
    const encoder = new TextEncoder();
    const key = encoder.encode(this.options.apiSecretKey);
    const data = encoder.encode(nonceStr);
    const algorithm = { name: 'HMAC', hash: 'SHA-1' };
    const hmac = await crypto.subtle.importKey('raw', key, algorithm, false, ['sign']);
    const signed = await crypto.subtle.sign(algorithm.name, hmac, data);
    return _hexDigest(signed);
  }

  public async encryptPassword(password: string) {
    const encodedPassword = new TextEncoder().encode(password);
    const digestedPassword = await crypto.subtle.digest('SHA-1', encodedPassword);
    return _hexDigest(digestedPassword);
  }
}

const _hexDigest = (buf: ArrayBuffer): string =>
  Array.from(new Uint8Array(buf))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
